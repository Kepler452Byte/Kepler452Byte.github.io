---
icon: pen-to-square
date: 2025-08-23
category:
  - 笔试题
tag:
  - 容易
  - 中等
article: false
---
# 【美团秋招】【2025-08-23】 笔试题

## 笔试1

<aside>

### 题目描述

小美有 n个长方形，第 i个长方形的两条边长分别为 $x_i,y_i$。

小美拥有一个仅包含第一象限的平面直角坐标系。

她希望将这 n 个长方形 **按顺序**（可以旋转）放置在 xxx 轴上，要求：

1. 不允许重叠；
2. 每个长方形放置后的 **高度** 不超过 m；
3. 已知保证条件：$max(min(x_i,y_i))≤m$
    
    $max⁡(min⁡(x_i,y_i))≤m\max\left(\min(x_i, y_i)\right) \le m$
    

请问，在满足上述条件的前提下，小美最少需要占用 xxx 轴的长度是多少？

---

### 输入描述

- 第一行输入两个整数$n,m(1≤n≤2×105,1≤m≤109)$
    
    $n,m(1≤n≤2×105,  1≤m≤109)n, m \quad (1 \le n \le 2 \times 10^5,\; 1 \le m \le 10^9)$
    
    表示长方形的个数和允许的最大高度。
    
- 接下来 nnn 行，每行输入两个整数$x_i,y_i(1≤x_i,y_i≤109)$
    
    $x_i,y_i(1≤x_i,y_i≤10^9)x_i, y_i \quad (1 \le x_i, y_i \le 10^9)$
    
    表示第 i个长方形的两条边长。
    
</aside>

<aside>

### 问题分析

本题要求将n个长方形按顺序放置在x轴上，满足：

1. 长方形可以旋转（交换长和宽）
2. 每个长方形的高度不超过m
3. 长方形不能重叠
4. 目标是最小化占用的x轴总长度

关键约束：题目保证`$max(min(x_i, y_i)) ≤ m$`，即每个长方形至少有一条边可以作为高度（≤m），因此所有长方形都能合法放置。

### 解题思路

对于每个长方形，我们需要选择最优的放置方向以最小化x轴占用长度：

- 当长方形的两条边都≤m时（x≤m且y≤m）：可以自由选择方向，应取较短边作为x轴长度（宽度），较长边作为高度
- 当只有x≤m时：只能以x为高度，y必须作为x轴长度
- 当只有y≤m时：只能以y为高度，x必须作为x轴长度

将所有长方形的x轴长度累加，即为最小总长度。

### 代码解析

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        long totalLength = 0;  // 使用long防止整数溢出

        for (int i = 0; i < n; i++) {
            int x = in.nextInt();
            int y = in.nextInt();

            // 题目已保证此条件不会成立，可省略
            if (Math.min(x, y) > m) {
                System.out.println(-1);
                return;
            }

            if (x <= m && y <= m) {
                // 两边都可作为高度，选较短边作为宽度
                totalLength += Math.min(x, y);
            } else if (x <= m) {
                // 只能用x作为高度，y作为宽度
                totalLength += y;
            } else {
                // 只能用y作为高度，x作为宽度
                totalLength += x;
            }
        }

        System.out.println(totalLength);
    }
}

```

### 复杂度分析

- 时间复杂度：O(n)，只需遍历所有长方形一次
- 空间复杂度：O(1)，只需常数级别的额外空间

### 关键注意点

使用`long`类型存储总长度，因为n最大为2×10⁵，每个边长最大为10⁹，总和可能超过int的最大值（约2×10⁹），导致整数溢出。

</aside>

## 笔试2

<aside>

### 题目描述

小美有一个最喜欢的小于 ($2^{20}$) 的非负整数 ($x$)。我们称数组 (a) 是美丽的，当且仅当满足以下所有条件：

- 数组 (a) 中的每个元素都小于 ($2^{20}$)；
- 数组 (a) 中不包含相同的数；
- 对于数组 (a) 中任意两个处在不同位置的数 $(a_i) 和 (a_j)$，都满足 ($a_i \& a_j = x$)，其中 ($\&$) 为按位与运算。特别地，当数组长度为 1 时，也视为满足此条件。

现在小美想让你帮他找到一个最长的美丽数组，如果存在多个最长的美丽数组，你可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

### **输入描述**

每个测试文件均包含多组测试数据。第一行输入一个整数 $T$ ($1 \leq T \leq 500$)代表数据组数，每组测试数据描述如下：输入一行一个整数 $(x)（0 \leq x < 2^{20}）$，表示小美最喜欢的非负整数。

### **输出描述**

对于每组测试数据，先输出一行一个整数 $k(1 \leq k \leq 100)$，表示最长的美丽数组的长度。可以证明在本题的数据范围内，最长的美丽数组的长度不会超过 100。接下来，在第二行输出 $k$ 个不同整数 $(a_1, a_2, \dots, a_k)(0 \leq a_i < 2^{20})$，表示你找到的最长美丽数组。

</aside>

<aside>

### 问题分析

本题要求构造一个最长的"美丽数组"，满足以下条件：

1. 数组中每个元素都小于 $2^{20}$
2. 数组中不包含重复元素
3. 任意两个不同元素的按位与运算结果等于给定整数 x
4. 数组长度为1时也视为满足条件

核心挑战是理解按位与运算的特性，并利用这些特性构造最长数组。

### 解题思路

1. **按位与特性分析**：若 ($a \& b = x$)，则 a 和 b必须包含 $x$ 的所有二进制1位（即$a \& x = x$且 $b \& x = x$)
2. **元素构造方法**：
    - 基础元素：$x$ 本身必然在数组中（单个元素满足条件）
    - 扩展元素：对于 $x$ 二进制表示中为0的每一位，我们可以构造新元素 $x | (1 << i)$，其中 $i$ 是该0位的位置
3. **正确性证明**：
    - 新元素与 $x$ 的按位与结果为 $x$
    - 任意两个新元素的按位与结果也为 $x$（因为它们仅在 $x$ 的0位上有差异）
    - 所有元素均不重复且小于 $2^{20}$

### 代码解析

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        final int MAX = 1 << 20; // 2^20 = 1048576

        while (T-- > 0) {
            int v = scanner.nextInt();
            List<Integer> result = new ArrayList<>();

            // 加入基础元素v
            if (v < MAX) {
                result.add(v);
            }

            // 遍历20位，构造扩展元素
            for (int i = 0; i < 20; i++) {
                int mask = 1 << i; // 第i位的掩码
                // 只在v的第i位为0时构造新元素
                if ((v & mask) == 0) {
                    int num = v | mask;
                    if (num < MAX) {
                        result.add(num);
                    }
                }
            }

            // 输出结果
            System.out.println(result.size());
            for (int num : result) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
        scanner.close();
    }
}

```

### 复杂度分析

- 时间复杂度：$O(T \times 20）$，每组测试数据只需遍历20个二进制位
- 空间复杂度：$O(20)$，最多存储21个元素（1个基础元素+20个扩展元素）

### 示例说明

以 $x = 5$（二进制 `101`）为例：

- 基础元素：5（`101`）
- 扩展元素：
    - 第1位（从0开始）为$0：5 | 2 = 7$（`111`）
    - 第2位以上为0的位也可构造新元素
- 数组为 `[5, 7, ...]`，任意两元素按位与结果均为5

这种构造方法能保证得到最长的美丽数组，因为我们利用了所有可扩展的二进制位。

</aside>