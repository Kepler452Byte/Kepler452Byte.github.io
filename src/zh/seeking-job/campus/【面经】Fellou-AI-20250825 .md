---
icon: pen-to-square
date: 2025-08-25
category:
  - 求职经历
tag:
  - 面经
---
# 【面经】Fellou-AI-20250825
## JD调研

1. [34.与Fellou创始人谢扬的3小时访谈：孤独、95后、牌桌与生产力的完美创业 - 卫诗婕｜商业漫谈Jane's talk | 小宇宙 - 听播客，上小宇宙](https://www.xiaoyuzhoufm.com/episode/680b04ea7a449ae85895ba00)
    
    > Fellou 的四大核心能力：深度行动、主动智能、影子空间、智能体网络
    > 
2. https://hub.baai.ac.cn/view/45265
3. [(99+ 封私信 / 16 条消息) 功能强大的Dia浏览器，可能活不了太久 - 知乎](https://zhuanlan.zhihu.com/p/1913545774068917177)
    
    > 这年头，初创公司的创意，日后都会为巨头们所用。
    > 
    > 
    > 不说别的，Arc 浏览器最具特色的竖向标签页+ Pin书签，去年在好几家浏览器上很凑巧地出现了。
    > 
    > ![](https://pic3.zhimg.com/v2-596334eb0ddff97dbe5c1d2fac607be6_1440w.jpg)
    > 
    > 有只小松鼠在树林里苦苦寻找、试吃各种果子和坚果，摸索哪些能吃、哪些有毒、哪些最有营养。
    > 
    > 而大棕熊坐在树下，眯着眼睛观察。它不着急觅食，它知道：等小松鼠找到了食物，只要走过去，凭体型优势就能接管一切。
    > 
    > 巨头根本不着急做落地产品，他们只需要「 等待-观察-复制 」，由创业公司替其试错，然后坐享其成。
    > 
    > 所以 Dia 面临着：
    > 
    > **它的功能，别人三天就能复刻出来。**
    > 
    > **而别人的大模型，它这一辈子，也只能到用用 API 的程度。。。**（目前 Dia 用的是 [gpt-4.1](https://zhida.zhihu.com/search?content_id=258561728&content_type=Article&match_order=1&q=gpt-4.1&zhida_source=entity) ）
    > 
    > 那用户有什么理由，放弃原有浏览器，而选择你？
    > 
    > 浏览器，本就是一个护城河太深的领域。Chrome、Edge、Safari 谁家背后没一个大爹？
    > 
    > ![](https://pic4.zhimg.com/v2-fce3186e629138caf1a8f24c007a02bd_1440w.jpg)
    > 
    > 即便是市场份额低于 1% 的 Others ，他们也有千万、百万级别用户。
    > 
    > 不是喊喊口号，仅靠一些好的想法，拥有一群小众的极客粉丝，就能踏过巨头的护城河，抢夺他们的用户。
    > 
    > 尽管这个 Dia 在保持简洁同时还能精准提高我的生产力，我很喜欢。
    > 
    > **但我真不看好它的未来。（ Arc 浏览器已经停更了 ）**
    > 
    > 差友们现在可能用不上 Dia，它还在内测，仅支持 Mac，邀请码少之又少。即便能用上，对网络也有一定的要求。
    > 
    > 但别担心，很快（也可以说现在），你就能在别的浏览器里体验到这些功能。
    > 

## 面经

---

1. AK/SK 的实现
    1. 引入了缓存、在多个节点的情况下怎么保证所有缓存的一致性？
        - 使用消息队列同步
        - 使用轮询线程，保持与MySQL的启用状态一致
2. 有没有做多路召回？做RAG的时候文本分块是怎么做的？
    - **多路召回**：是指同时使用多种检索方式（如关键词、向量、标签过滤等）来获取候选文档，再合并结果，提高覆盖率和召回率。
    - **RAG中文本分块**：一般将长文本按段落、句子或固定长度（如512-1024 tokens）切分，然后对每个块做向量化或索引，方便检索和生成回答。
3. K8S的组件有哪些 APIServer etcd Node …
    
    1. **控制平面组件（Control Plane）**
    
    - **API Server**：所有请求的入口，提供 REST API，用于集群管理。
    - **etcd**：分布式键值存储，存储集群的状态数据（配置、状态等）。
    - **Controller Manager**：负责集群中各类控制器，确保实际状态与期望状态一致（如 Deployment、Node）。
    - **Scheduler**：负责 Pod 调度，把 Pod 分配到合适的 Node 上。
    
    ---
    
    2. **节点组件（Node/Worker）**
    
    - **kubelet**：节点上的核心 agent，负责管理 Pod 生命周期，向 API Server 汇报状态。
    - **kube-proxy**：实现服务的网络代理和负载均衡。
    - **Container Runtime**：容器运行时，如 Docker、containerd，用于实际运行容器。
    
    ---
    
    一句话总结面试用：
    
    > Kubernetes 的核心组件包括控制平面的 API Server、etcd、Scheduler、Controller Manager，以及节点上的 kubelet、kube-proxy 和容器运行时。
    > 
4. redis的布隆过滤器的实现原理？bitmap大小？
    1. 哈希 + bitmap
    
    **原理**
    
    1. **布隆过滤器（Bloom Filter）是一种空间效率很高的概率型数据结构**，用于判断一个元素是否存在集合中。
    2. 它由一个**位数组（bitmap）和多个哈希函数**组成：
        - 插入元素时，对元素计算 `k` 个哈希值，对应位数组的位置置为 1。
        - 查询元素时，对元素计算同样的 `k` 个哈希值，如果对应位都是 1，则认为元素可能存在，否则一定不存在。
    3. **特点**：可能有 **假阳性**（存在但返回不存在），不会有假阴性。
    
    ---
    
    **Bitmap 大小**
    
    - Redis 的 Bloom Filter 实际上是用一个**固定长度的 bitmap**存储的。
    - 大小通常取决于**预估的元素数量 `n`** 和 **允许的误判率 `p`**，公式如下：
        - **位数组大小 m**：`m = -(n * ln(p)) / (ln2)^2`
        - **哈希函数个数 k**：`k = (m / n) * ln2`
    - Redis 的 `bf.reserve` 命令可以直接指定预估元素数量和误判率，内部会自动计算 bitmap 大小和哈希函数数量。
    
    ---
    
    一句话总结面试用：
    
    > Redis 布隆过滤器用一个位数组和多个哈希函数判断元素是否存在，空间效率高，可配置大小和误判率，可能出现假阳性但不会漏报。
    > 
5. ~~为什么要对任务入参做哈希去重，加上时间了之后不是已经唯一了吗？~~
6. 互斥锁与排他锁是什么
    
    **互斥锁（Mutex）**
    
    - 是**操作系统或程序内部的锁**，用于保护**共享资源在同一时间只能被一个线程访问**。
    - 本质是**线程级别的同步机制**，防止多线程同时操作共享数据导致冲突。
    - 特点：
        - 只在同一进程内生效（不同进程需要其他机制，如信号量）。
        - 上锁和解锁由程序控制。
    
    ---
    
    **排他锁（Exclusive Lock / 写锁）**
    
    - 是**数据库或文件系统中用于并发控制的锁**，保证**同一资源在锁定期间只能被一个事务或进程修改**。
    - 本质是**事务级别或进程级别的同步机制**。
    - 特点：
        - 其他事务/进程无法对该资源加读锁或写锁。
        - 常用于保证数据一致性和防止脏写。
    
    ---
    
    **一句话总结**
    
    > 互斥锁用于多线程程序中保护共享内存资源；排他锁用于数据库或文件系统中保证资源在一个事务/进程修改时不被其他人访问。
    > 
7. 有一张表建立了（a, b）联合索引 select a, b from table where a = xxx; 能走到索引吗？（索引下推）
    1. **联合索引 `(a, b)` 的最左前缀原则**：
        - 联合索引能被利用的前提是查询条件包含索引最左边的列。
        - 比如 `(a, b)`：
            - `WHERE a = ?` ✅ 可以走索引
            - `WHERE a = ? AND b = ?` ✅ 可以走索引
            - `WHERE b = ?` ❌ 不走索引
    2. **这个例子**
    
    ```sql
    SELECT a, b FROM table WHERE a = xxx;
    ```
    
    - 条件只涉及索引的最左列 `a`，所以**可以走联合索引**。
    - 查询只返回 `a, b` 两列，也可以走**覆盖索引**（不回表）。
    
    > **正确的 ICP 示例**
    > 
    > 
    > sql
    > 
    > - `*- 表结构*
    > CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50), age INT, city VARCHAR(50), salary INT, INDEX idx_name_age (name, age)
    > );
    > *- 会触发 ICP 的查询*
    > SELECT id, name, city, salary
    > FROM users
    > WHERE name = 'Alice' AND age > 30;`
    > 
    > **ICP 工作原理：**
    > 
    > 1. **索引能用的部分**：`name = 'Alice'` (精确匹配)
    > 2. **索引不能完全用的部分**：`age > 30` (范围查询，但仍在索引列中)
    > 3. **查询需要的其他列**：`city, salary` (不在索引中，需要回表)
    > 
    > **ICP 优化过程：**
    > 
    > **没有 ICP 时：**
    > 
    > `1. 用索引找到所有 name='Alice' 的记录
    > 2. 对每条记录都回表获取完整行数据
    > 3. 在 MySQL Server 层过滤 age > 30`
    > 
    > **有 ICP 时：**
    > 
    > `1. 用索引找到所有 name='Alice' 的记录
    > 2. ✅ 在存储引擎层直接用 age > 30 过滤
    > 3. 只对通过过滤的记录回表获取 city, salary
    > 4. 减少了回表次数`
    > 
8. Redis 哨兵模式，有哪些角色？主从同步？RDB AOF 在主从同步中的作用
    
    **Redis 哨兵模式角色**
    
    **核心角色：**
    
    1. **Master（主节点）**：处理写请求和读请求
    2. **Slave（从节点）**：只处理读请求，从 Master 同步数据
    3. **Sentinel（哨兵节点）**：监控集群健康状态，执行故障转移
    
    **哨兵职责：**
    
    - **监控**：定期检查 Master/Slave 是否正常工作
    - **通知**：当实例故障时通知管理员或客户端
    - **自动故障转移**：Master 宕机时自动选举新 Master
    - **配置提供者**：为客户端提供当前 Master 地址
    
    **主从同步机制**
    
    **全量同步（第一次）：**
    
    ```
    1. Slave 连接 Master，发送 PSYNC 命令
    2. Master 执行 BGSAVE 生成 RDB 快照
    3. Master 将 RDB 文件传输给 Slave
    4. Slave 加载 RDB 文件恢复数据
    5. Master 将期间的写命令通过复制缓冲区发送给 Slave
    
    ```
    
    **增量同步（日常）：**
    
    ```
    1. Master 将写命令实时发送给 Slave
    2. Slave 执行这些命令保持数据同步
    3. 使用复制偏移量（replication offset）确保一致性
    
    ```
    
    **RDB 和 AOF 在主从同步中的作用**
    
    **RDB 作用：**
    
    - **全量同步的载体**：Master 生成 RDB 快照发送给 Slave
    - **快速恢复**：Slave 通过加载 RDB 文件快速获得完整数据集
    - **节省带宽**：相比发送所有历史命令，RDB 更紧凑
    
    **AOF 作用：**
    
    - **增量同步**：Master 将写命令实时同步给 Slave
    - **数据一致性保障**：确保 Slave 与 Master 数据完全一致
    - **断线重连优化**：通过复制缓冲区实现部分重同步
    
    **协同工作：**
    
    - RDB 负责**批量数据传输**（全量同步）
    - AOF 负责**实时命令同步**（增量同步）
    - 两者结合保证主从数据的最终一致性
    
    > **一句话总结**
    > 
    > 
    > Redis 哨兵模式通过 Master/Slave/Sentinel 三种角色实现高可用，其中 RDB 负责主从间的全量数据同步，AOF 负责实时命令同步，哨兵负责监控和自动故障转移。
    > 
9. MySQL 事物的隔离级别，4个，具体指的是什么？
    
    > **1. 脏读（Dirty Read）**
    > 
    > 
    > **定义**：读取到其他事务**未提交**的数据
    > 
    > **2. 不可重复读（Non-Repeatable Read）**
    > 
    > **定义**：同一事务内，多次读取**同一行数据**结果不一致
    > 
    > **3. 幻读（Phantom Read）**
    > 
    > **定义**：同一事务内，多次执行**同一查询条件**，返回的**行数**不一致（出现了"幻影行"）
    > 
    
    **1. READ UNCOMMITTED（读未提交）**
    
    **定义**：可以读取到其他事务未提交的数据
    
    **问题**：会出现脏读、不可重复读、幻读
    
    **实际应用**：几乎不使用，数据一致性最差
    
    **2. READ COMMITTED（读已提交）**
    
    **定义**：只能读取到其他事务已提交的数据
    
    **问题**：解决了脏读，但仍有不可重复读、幻读
    
    **实际应用**：Oracle、SQL Server 默认级别
    
    **3. REPEATABLE READ（可重复读）**
    
    **定义**：在同一事务内多次读取同一数据结果一致
    
    **问题**：解决了脏读、不可重复读，但理论上仍有幻读（MySQL 的 InnoDB 通过 MVCC + Next-Key Lock 基本解决了幻读）
    
    **实际应用**：**MySQL InnoDB 默认级别**
    
    **4. SERIALIZABLE（串行化）**
    
    **定义**：事务串行执行，完全隔离
    
    **问题**：解决所有并发问题，但性能最差
    
    **实际应用**：很少使用，除非对数据一致性要求极高
    
    | **事务隔离级别（Transaction Isolation Level）** | **脏读（Dirty Read）** | **不可重复读（Non-Repeatable Read）** | **幻读（Phantom Read）** | **性能表现** |
    | --- | --- | --- | --- | --- |
    | **READ UNCOMMITTED（读未提交）** | ✗（允许） | ✗（允许） | ✗（允许） | 最高 |
    | **READ COMMITTED（读已提交）** | ✓（禁止） | ✗（允许） | ✗（允许） | 较高 |
    | **REPEATABLE READ（可重复读）** | ✓（禁止） | ✓（禁止） | ✗（允许）* | 较低 |
    | **SERIALIZABLE（串行化）** | ✓（禁止） | ✓（禁止） | ✓（禁止） | 最低 |
    - 注：MySQL InnoDB 在 REPEATABLE READ 级别下通过 MVCC + Next-Key Lock 基本解决了幻读问题
    
    > **一句话总结**
    > 
    > 
    > MySQL 四个事务隔离级别按隔离程度递增：读未提交（性能最高但有脏读）→ 读已提交（解决脏读）→ 可重复读（MySQL 默认，基本解决所有并发问题）→ 串行化（完全隔离但性能最差）。
    > 
10. 怎么防止超卖的问题？LUA脚本？查询库存与预扣减库存是在一个lua脚本中的吗？
    - **“查询库存” 与 “预扣减库存” 必须放在同一个 Lua 脚本中执行**—— 因为 Redis 会将整个 Lua 脚本作为**单个命令**处理，在脚本执行期间会阻塞其他对该 Redis 键的操作，从而彻底保证 “检查 - 扣减” 的原子性，从根源杜绝超卖。
    - Redis 是**单线程处理命令**的（指核心的命令执行模块，网络 IO 是多线程），当执行 Lua 脚本时，Redis 会：
        1. 暂停处理其他所有命令请求；
        2. 从头到尾执行整个 Lua 脚本（中间不会被打断）；
        3. 脚本执行完成后，再恢复处理其他命令。
    - **不是 “无锁”，而是 “用更优的同步替代显式锁”**：
        - Redis 层面用 “单线程原子脚本” 替代应用层分布式锁；
        - MySQL 层面用 “行锁 / 乐观锁” 做最终保障，但只作用于少量请求。
    
    这种 “单线程 + 脚本整体执行” 的特性，确保了 “查询库存” 与 “扣减库存” 不会被并发请求插入，彻底避免超卖。
    
11. ~~你们的MCP Server是怎么做的？~~
    
    

## 手撕

---

合并链表 递归 迭代

- 递归

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 终止条件：其中一个链表为空，返回另一个
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        
        // 选择值较小的节点作为当前合并节点
        if (l1.val <= l2.val) {
            // 递归合并 l1 的 next 与 l2，结果挂到 l1.next
            l1.next = mergeTwoLists(l1.next, l2);
            return l1; // 返回当前选中的 l1 作为头节点
        } else {
            // 递归合并 l2 的 next 与 l1，结果挂到 l2.next
            l2.next = mergeTwoLists(l1, l2.next);
            return l2; // 返回当前选中的 l2 作为头节点
        }
    }
}
```

- 迭代

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头节点：简化边界处理
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy; // curr 指向合并链表的当前末尾
        
        ListNode p1 = l1; // 遍历 l1 的指针
        ListNode p2 = l2; // 遍历 l2 的指针
        
        // 遍历两个链表，直到其中一个为空
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                curr.next = p1; // 接入 p1
                p1 = p1.next;   // p1 后移
            } else {
                curr.next = p2; // 接入 p2
                p2 = p2.next;   // p2 后移
            }
            curr = curr.next; // curr 后移，保持在末尾
        }
        
        // 接入剩余节点（其中一个链表已遍历完）
        curr.next = (p1 != null) ? p1 : p2;
        
        return dummy.next; // 返回合并链表的真正头节点
    }
}
```